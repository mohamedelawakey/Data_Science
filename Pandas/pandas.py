# -*- coding: utf-8 -*-
"""pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XzVN3n_ODL5A0Cbz6C6nwtWgxTCH6UTf

# Introduction to pandas Data Structures
"""

import pandas as pd
import numpy as np
from pandas import Series, DataFrame

"""# Series"""

se = pd.Series([4, 7, -5, 3]) # make Series object (index, values)
print(se)
print('-' * 50)
print(se.array) # return values as Pandas Extension Array (type, array, Length, dtype)
print('-' * 50)
print(se.index) # get the start and end of the array and steps
print('-' * 50)
se2 = pd.Series([4, 7, -5, 3], index=['a', 'b', 'c', 'd']) # change the index name
print(se2)
print('-' * 50)
print(se2.index) # get the start and end of the array and steps
print('-' * 50)
print(se2["a"])
print('-' * 50)
se2["a"] = 6
print(se2[["a", "b", "c"]])
print('-' * 50)
print(se2[se2 > 0])
print('-' * 50)
print(se2 * 2)
print('-' * 50)
print(np.exp(se2))
print('-' * 50)
print('b' in se2)
print('s' in se2)
print('-' * 50)
sdata = {"Ohio": 35000, "Texas": 71000, "Oregon": 16000, "Utah": 5000} # Ohio = index, 35000 = value,......
se3 = pd.Series(sdata) # convert dictionary to series
print(se3)
print('-' * 50)
print(se3.to_dict()) # convert from series to dictionary
print('-' * 50)
states = ["California", "Ohio", "Oregon", "Texas"]
se4 = pd.Series(sdata, index = states) # create series use sdata as data and states as indexes
print(se4)
print('-' * 50)
print(se4.isna()) # check if there nan values in data
print('-' * 50)
print(se4.notna()) # check if there non nan values in data
print('-' * 50)
print(se3 + se4)
print('-' * 50)
se4.name = "population" # name of series
se4.index.name = 'state' # name of index of name
print(se4)
print('-' * 50)
se.index = ["Bob", "Steve", "Jeff", "Ryan"]
print(se)
print('-' * 50)

"""# DataFrame"""

data = {"state": ["Ohio", "Ohio", "Ohio", "Nevada", "Nevada", "Nevada"],
        "year": [2000, 2001, 2002, 2001, 2002, 2003],
        "pop": [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]
        }
frame = pd.DataFrame(data)
frame

frame.head() # get the first 5 rows

frame.tail() # get the last 5 rows

pd.DataFrame(data, columns=["year", "state", "pop"]) # change columns name

frame2 = pd.DataFrame(data, columns=["year", "state", "pop", "debt"])
frame2

frame2.columns # know the columns name

frame2['state'] # get the column of state

frame2.year # get the year column

frame2.loc[1] # use the label / index

frame2.iloc[2] # use the position

frame2['debt'] = np.arange(6.0)
frame2

val = pd.Series([-1.2, -1.5, -1.7], index=["two", "four", "five"]) # create series
frame2["debt"] = val

frame2

frame2['eastern'] = frame2['state'] == 'Ohio' # make a new column 'eastern' have values if state = Ohio or no

frame2

frame2['eastern'] = frame2['state'] == 'Ohio' # make a new column 'eastern' have values if state = Ohio or no

frame2

del frame2['eastern'] # delete column 'eastern'

frame2.columns

populations = {"Ohio": {2000: 1.5, 2001: 1.7, 2002: 3.6},"Nevada": {2001: 2.4, 2002: 2.9}}
frame3 = pd.DataFrame(populations) # create a DataFrame from dect

print(frame3)
print('-' * 30)
print(frame3.T)
print('-' * 30)
pd.DataFrame(populations, index=[2001, 2002, 2003]) # edit the index of frame3
print(frame3)
print('-' * 30)

pdata = {"Ohio": frame3["Ohio"][:-1],"Nevada": frame3["Nevada"][:2]}
pd.DataFrame(pdata)
print(pdata)
print('-' * 30)
frame3.index.name = "year"
frame3.columns.name = "state"
print(frame3)
print('-' * 30)
print(frame3.to_numpy())
print('-' * 30)
print(frame2.to_numpy())
print('-' * 30)

"""# Index Objects"""

ob_inx = pd.Series(np.arange(3), index=["a", "b", "c"])
in_d = ob_inx.index
print(in_d)
print('-' * 30)
print(in_d[1:])
# in_d[1] = 's' --> TypeError
print('-' * 30)
labels = pd.Index(np.arange(3))
print(labels)
print('-' * 30)
ob_inx_2 = pd.Series([1.5, -2.5, 0], index=labels)
print(ob_inx_2)
print('-' * 30)
print(ob_inx_2.index is labels) # chaeck if ob_inx_2 and labels are the same object
print('-' * 30)
print(frame3)
print('-' * 30)
print(frame3.columns)
print('-' * 30)
print('Ohio' in frame3.columns)
print('-' * 30)
print(2003 in frame3.index)
print('-' * 30)
print(pd.Index(["foo", "foo", "bar", "bar"])) # build index
print('-' * 30)

"""# Essential Functionality

## Reindexing
"""

rind = pd.Series([4.5, 7.2, -5.3, 3.6], index = ["d", "b", "a", "c"])
rind

# to reindex
rind_2 = rind.reindex(["a", "b", "c", "d", "e"])
rind_2

rind_3 = pd.Series(["blue", "purple", "yellow"], index = [0,2,4])
rind_3

rind_3.reindex(np.arange(6), method='ffill') # if any new values is nan so fill it with the last value

frame_re = pd.DataFrame(np.arange(9).reshape((3,3)), index = ["a", "c", "d"], columns = ["Ohio", "Texas", "California"])
frame_re

frame_re_2 = frame_re.reindex(index = ["a", "b", "c", "d"])
frame_re_2

states =  ["Texas", "Utah", "California"]

frame_re.reindex(columns = states)

frame_re.loc[["a", "d", "c"], ["California", "Texas"]]

"""## Dropping Entries from an Axis"""

drefaa = pd.Series(np.arange(5.), index=["a", "b", "c", "d", "e"])
drefaa

new_drefaa = drefaa.drop('c')
new_drefaa

drefaa2 = drefaa.drop(["d", "c"])
drefaa2

drefaa_nn = pd.DataFrame(np.arange(16).reshape((4, 4)),index=["Ohio", "Colorado", "Utah", "New York"],columns=["one", "two", "three", "four"])
drefaa_nn

# drefaa_nn.drop(columns=['two'])
drefaa_nn.drop("two", axis=1)

drefaa_nn.drop(['two', 'four'], axis = 'columns')

"""## Indexing, Selection, and Filtering"""

drefaa_isf = pd.Series(np.arange(4.), index=["a", "b", "c", "d"])
drefaa_isf

print('-' * 30)
print(drefaa_isf['b']) # Access value by label 'b'
print('-' * 30)
print(drefaa_isf[1]) # Access value by integer position 1 (may be confusing if index labels are integers)
print('-' * 30)
print(drefaa_isf[2:4]) # Slice by position, returns items from index 2 up to (not including) 4
print('-' * 30)
print(drefaa_isf[["b", "a", "d"]]) # Select multiple items by label
print('-' * 30)
print(drefaa_isf[[1,3]]) # Select multiple items by integer positions
print('-' * 30)
print(drefaa_isf[drefaa_isf < 2]) # Boolean indexing: returns items where value < 2
print('-' * 30)
print(drefaa_isf.loc[["b", "a", "d"]]) # Select multiple items using loc (label-based selection, preferred)
print('-' * 30)

drefaa_isf_1 = pd.Series([1, 2, 3], index = [2, 0, 1]) # Create a Series with integer labels not in order
drefaa_isf_2 = pd.Series([1, 2, 3], index=["a", "b", "c"]) # Create a Series with string labels

print(drefaa_isf_1)
print('-' * 30)
print(drefaa_isf_2)
print('-' * 30)
print(drefaa_isf_1[[0, 1, 2]]) # Select elements from drefaa_isf_1 using Python-style positional indexing (may cause confusion!)
print('-' * 30)
print(drefaa_isf_2[[0, 1, 2]]) # Select elements from drefaa_isf_2 using Python-style positional indexing
print('-' * 30)
print(drefaa_isf_1.iloc[[0, 1, 2]]) # Correct way to select by position using iloc
print('-' * 30)
print(drefaa_isf_2.iloc[[0, 1, 2]]) # Correct way to select by position using iloc
print('-' * 30)
print(drefaa_isf_2.loc["b":"c"]) # Select a range of labels using loc
print('-' * 30)
drefaa_isf_2.loc["b":"c"] = 5 # Assign new values to a slice using loc
print(drefaa_isf_2)
print('-' * 30)

# Create a 4x4 DataFrame with custom row and column labels
drefaa_isf_3 = pd.DataFrame(np.arange(16).reshape((4, 4)),index=["Ohio", "Colorado", "Utah", "New York"],columns=["one", "two", "three", "four"])
print(drefaa_isf_3)
print('-' * 30)
print(drefaa_isf_3['two']) # Select a single column 'two'
print('-' * 30)
print(drefaa_isf_3[["three", "one"]]) # Select multiple columns 'three' and 'one'
print('-' * 30)
print(drefaa_isf_3[:2]) # Select the first two rows using slicing
print('-' * 30)
print(drefaa_isf_3[drefaa_isf_3['three'] > 5]) # Select rows where the 'three' column value is greater than 5
print('-' * 30)
print(drefaa_isf_3 < 5) # Boolean DataFrame: True if value < 5, False otherwise
print('-' * 30)
drefaa_isf_3[drefaa_isf_3 < 5] = 0 # Replace all values less than 5 with 0
print(drefaa_isf_3)
print('-' * 30)

# Selection on DataFrame with loc and iloc
print(drefaa_isf_3.loc['Colorado']) # Select the row with index 'Colorado'
print('-' * 30)
print(drefaa_isf_3.loc['Colorado', ['two', 'three']]) # Select columns 'two' and 'three' for the row 'Colorado'
print('-' * 30)
print(drefaa_isf_3.iloc[2]) # Select the 3rd row by integer position
print('-' * 30)
print(drefaa_isf_3.iloc[[2, 1]]) # Select multiple rows by position (3rd and 2nd)
print('-' * 30)
print(drefaa_isf_3.iloc[2, [3, 0, 1]]) # Select specific row and columns by integer positions
print('-' * 30)
print(drefaa_isf_3.iloc[[1, 2], [3, 0, 1]]) # Select multiple rows and columns by integer positions
print('-' * 30)
print(drefaa_isf_3.loc[:"Utah", "two"]) # Select 'two' column for all rows up to 'Utah'
print('-' * 30)
print(drefaa_isf_3.iloc[:, :3][drefaa_isf_3.three > 5]) # Select first 3 columns where 'three' > 5
print('-' * 30)
print(drefaa_isf_3[drefaa_isf_3.three >= 2]) # Select all rows where 'three' >= 2
print('-' * 30)

# Pitfalls with chained indexing
drefaa_isf_3.loc[:, 'one'] = 1 # Set all values in column 'one' to 1
print(drefaa_isf_3)
print('-' * 30)
drefaa_isf_3.iloc[2] = 5 # Set all values in the 3rd row (index 2) to 5
print(drefaa_isf_3)
print('-' * 30)
drefaa_isf_3.loc[drefaa_isf_3['four'] > 5] = 3 # Set all rows where column 'four' > 5 to 3
print(drefaa_isf_3)
print('-' * 30)
drefaa_isf_3.loc[drefaa_isf_3.three == 5, 'three'] = 6 # Set 'three' column to 6 where it is currently 5
print(drefaa_isf_3)
print('-' * 30)

"""## Arithmetic and Data Alignment"""

s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=["a", "c", "d", "e"]) # Create first Series with custom index
s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1],index=["a", "c", "e", "f", "g"]) # Create second Series with different index, some overlap with s1

print(s1)
print('-' * 30)
print(s2)
print('-' * 30)
# Add the two Series together, Only indices that exist in both Series will be summed, Indices that are missing in one Series will result in NaN
print(s1 + s2)
print('-' * 30)

# Create first DataFrame with columns 'b', 'c', 'd' and custom index
df1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list("bcd"),index=["Ohio", "Texas", "Colorado"])
# Create second DataFrame with columns 'b', 'd', 'e' and different index
df2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list("bde"),index=["Utah", "Ohio", "Texas", "Oregon"])

print(df1)
print('-' * 30)
print(df2)
print('-' * 30)
# Add df1 and df2 together, Only the overlapping rows (index) and columns are summed, Non-overlapping rows/columns will result in NaN
print(df1 + df2)
print('-' * 30)

df_set1 = pd.DataFrame({"A": [1, 2]}) # Create the first DataFrame with a single column 'A' and 2 rows
df_set2 = pd.DataFrame({"B": [3, 4]}) # Create the second DataFrame with a single column 'B' and 2 rows

print(df_set1)
print('-' * 30)
print(df_set2)
print('-' * 30)
print(df_set1 + df_set2) # Adding DataFrames sums only overlapping labels; non-overlapping columns result in NaN
print('-' * 30)

# Arithmetic methods with fill values
AMWFL1 = pd.DataFrame(np.arange(12.).reshape((3, 4)),columns=list("abcd"))
AMWFL2 = pd.DataFrame(np.arange(20.).reshape((4, 5)),columns=list("abcde"))

print(AMWFL1)
print('-' * 30)
print(AMWFL2)
print('-' * 30)
AMWFL2.loc[1, 'b'] = np.nan
print(AMWFL2)
print('-' * 30)
print(AMWFL1 + AMWFL2)
print('-' * 30)
AMWFL1.add(AMWFL2, fill_value=0) # Adds two DataFrames/Series (AMWFL1 + AMWFL2) and fills missing labels with 0 instead of NaN
print('-' * 30)

print(1 / AMWFL1)
print('-' * 30)

print(AMWFL1.rdiv(1)) # reverse division
print('-' * 30)

# Reindex AMWFL1 to have the same columns as AMWFL2, Any missing columns in AMWFL1 will be filled with 0
print(AMWFL1.reindex(columns = AMWFL2.columns, fill_value = 0))
print('-' * 30)

# Operations between DataFrame and Series

arr_obdas = np.arange(12.).reshape((3, 4)) # Create a NumPy array with values 0–11 reshaped into 3x4
print(arr_obdas)
print('-' * 30)
print(arr_obdas[0]) # the first row of the array
print('-' * 30)
print(arr_obdas - arr_obdas[0]) # Subtract the first row from every row (broadcasting)
print('-' * 30)

# Create DataFrame with values 0–11 reshaped into 4x3, columns b,d,e and row indexes
frame_obdas = pd.DataFrame(np.arange(12.).reshape((4, 3)),columns=list("bde"),index=["Utah", "Ohio", "Texas", "Oregon"])
series = frame_obdas.iloc[0] # Select the first row as a Series
print(frame_obdas)
print('-' * 30)
print(series)
print('-' * 30)
print(frame_obdas - series) # Subtract the Series from each row of the DataFrame (row-wise broadcasting)
print('-' * 30)

series2 = pd.Series(np.arange(3), index=["b", "e", "f"]) # Create a Series with indexes b, e, f
print(series2)
print('-' * 30)
print(frame_obdas + series2) # Add DataFrame and Series2 (aligning on column names)
print('-' * 30)
series3 = frame_obdas["d"] # Take column 'd' from DataFrame as a Series
print(frame_obdas)
print('-' * 30)
print(series3)
print('-' * 30)
print(frame_obdas.sub(series3, axis = 'index')) # Subtract series3 from DataFrame row-wise using index alignment
print('-' * 30)

"""# Function Application and Mapping"""

# Create a DataFrame with random values (4 rows × 3 columns), columns b,d,e and given row indexes
frame_faam = pd.DataFrame(np.random.standard_normal((4, 3)),columns=list("bde"),index=["Utah", "Ohio", "Texas", "Oregon"])
print(frame_faam)
print('-' * 40)
print(np.abs(frame_faam)) # the absolute values of all elements in the DataFrame (convert negatives to positives)
print('-' * 40)

def f1(x):
  return x.max() - x.min() # returns the range (max - min) of x

print(frame_faam.apply(f1)) # Apply f1 to each column of the DataFrame
print('-' * 40)
print(frame_faam.apply(f1, axis = 'columns')) # Apply f1 to each row of the DataFrame
print('-' * 40)

def f2(x):
  return pd.Series([x.min(), x.max()], index = ['min', 'max']) # returns a Series containing min and max of x

print(frame_faam.apply(f2)) # Apply f2 to each column
print('-' * 40)

def my_format(x):
  return f'{x:.2f}' # format numbers to 2 decimal places

print(frame_faam.applymap(my_format)) # Apply my_format element-wise to every value in the DataFrame
print('-' * 40)

print(frame_faam['e'].map(my_format)) # Apply my_format to each element of column 'e' (Series level)
print('-' * 40)

"""# Sorting and Ranking"""

obj_sar = pd.Series(np.arange(4), index=["d", "a", "b", "c"]) # Create a Series with values 0–3 and custom index labels
print(obj_sar)
print('-' * 40)
print(obj_sar.sort_index()) # sort by index 'a', 'b' ....
print('-' * 40)
# Create a DataFrame with values 0–7 reshaped into 2x4, Row indexes are 'three' and 'one', column labels are d, a, b, c
frame_sar = pd.DataFrame(np.arange(8).reshape((2, 4)),index=["three", "one"],columns=["d", "a", "b", "c"])
print(frame_sar)
print('-' * 40)
print(frame_sar.sort_index()) # sort by index 'a', 'b' ....
print('-' * 40)
print(frame_sar.sort_index(axis = 'columns')) # sort by columns
print('-' * 40)
print(frame_sar.sort_index(axis = 'columns', ascending=False)) # sort by columns Descending
print('-' * 40)
obj_ser = pd.Series([4, 7, -3, 2]) # Create a Series with 4 numeric values
obj_ser_2 = pd.Series([4, np.nan, 7, np.nan, -3, 2]) # Create another Series with some NaN (missing) values
print(obj_ser.sort_values()) # sort by values
print('-' * 40)
print(obj_ser_2.sort_values()) # sort by values
print('-' * 40)
print(obj_ser_2.sort_values(na_position='first')) # sort by values, nay nan values in the first
print('-' * 40)
# Create a DataFrame with two columns 'b' and 'a', 'b' has values [4, 7, -3, 2], 'a' has values [0, 1, 0, 1]
frame_sar = pd.DataFrame({"b": [4, 7, -3, 2], "a": [0, 1, 0, 1]})
print(frame_sar)
print('-' * 40)
print(frame_sar.sort_values('b')) # sort by values 'b'
print('-' * 40)
print(frame_sar.sort_values(['a', 'b'])) # sort by values 'a' then 'b'
print('-' * 40)
obj_ser2 = pd.Series([7, -5, 7, 4, 2, 0, 4]) # Create a Series with some numbers
print(obj_ser2.rank()) # Compute the ranks of each element (smaller numbers get smaller ranks; ties get average rank)
print('-' * 40)
print(obj_ser2.rank(method = 'first')) # Rank elements in the Series by order of appearance for ties (method="first")
print('-' * 40)
print(obj_ser2.rank(ascending=False)) # Rank elements in the Series in descending order (largest number gets rank 1)
print('-' * 40)
frame_sar_2 = pd.DataFrame({"b": [4.3, 7, -3, 2], "a": [0, 1, 0, 1],"c": [-2, 5, 8, -2.5]}) # Create a DataFrame with 3 columns 'b', 'a', 'c'
print(frame_sar_2.rank(axis="columns")) # Rank values row-wise (across columns) for each row

"""# Axis Indexes with Duplicate Labels"""

obj_aiwdl = pd.Series(np.arange(5), index=["a", "a", "b", "b", "c"]) # Create a Series with values 0–4 and duplicate index labels

print(obj_aiwdl)
print('-' * 40)
# Check if the Series index has all unique labels, True → All indicators are unique, False → There are duplicate indicators.
print(obj_aiwdl.index.is_unique)
print('-' * 40)
print(obj_aiwdl['a']) # Access all values corresponding to index 'a' (duplicates allowed)
print('-' * 40)
print(obj_aiwdl['c']) # Access the value corresponding to index 'c' (unique)
print('-' * 40)
# Create a DataFrame with random numbers and duplicate row indexes
obj_aiwdl_2 = pd.DataFrame(np.random.standard_normal((5, 3)),index=["a", "a", "b", "b", "c"])
print(obj_aiwdl_2)
print('-' * 40)
print(obj_aiwdl_2.loc['b']) # Access all rows corresponding to index 'b'
print('-' * 40)
print(obj_aiwdl_2.loc['c']) # Access the row corresponding to index 'c' (unique)
print('-' * 40)

"""# Summarizing and Computing Descriptive Statistics"""

# Create a DataFrame with some NaN values, Rows indexed by 'a', 'b', 'c', 'd'; columns are 'one' and 'two'
sacds_1 = pd.DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.75, -1.3]], index=["a", "b", "c", "d"], columns = ["one", "two"])
print(sacds_1)
print('-' * 40)
print(sacds_1.sum()) # Compute the sum of each column in the DataFrame, ignoring NaN by default
print('-' * 40)
print(sacds_1.sum(axis='columns')) # Sum all values in each column of the DataFrame, ignoring NaN by default
print('-' * 40)
# Sum across rows, NaN values will NOT be ignored, so if there's a NaN in the row, the sum will be NaN
print(sacds_1.sum(axis = 'index', skipna = False))
print('-' * 40)
# Calculate sum across each row (axis='columns'), if a row contains NaN, the result will be NaN
print(sacds_1.sum(axis = 'columns', skipna = False))
print('-' * 40)
print(sacds_1.mean(axis = 'columns')) # Calculate the mean across each row (axis='columns')
print('-' * 40)
print(sacds_1.idxmax()) # Return index (row label) of the first occurrence of the maximum value in each column
print('-' * 40)
print(sacds_1.cumsum()) # cumulative sum
print('-' * 40)
print(sacds_1.describe()) # summary statistics
print('-' * 40)

"""# Correlation and Covariance

## What does correlation mean?
Correlation measures how closely two movements (series) are moving together:
- Close to 1.0 → Their movement is similar
- Close to -1.0 → Their movement is opposite
- Close to 0 → There is no clear relationship

## What does covariance mean?

- Covariance also measures the relationship, but in the original units of the data (not normalized like correlation). It's difficult to interpret directly, but it's important in some analyses.
"""

# Create a DataFrame with stock prices for AAPL, GOOG, and MSFT over 5 days
data = {
    "AAPL": [100, 102, 101, 105, 107],
    "GOOG": [200, 202, 198, 207, 210],
    "MSFT": [50, 51, 49, 52, 54]
}

price = pd.DataFrame(data)
print("Prices:\n", price)
print('-' * 40)

returns = price.pct_change() # Calculate daily returns using pct_change(), (current price - previous price) / previous price
print("Returns:\n", returns)
print('-' * 40)
# Calculate correlation between AAPL and MSFT, correlation ranges from -1 (opposite) to +1 (perfectly aligned)
print("Correlation AAPL & MSFT:", returns["AAPL"].corr(returns["MSFT"]))
print('-' * 40)
# Calculate covariance between AAPL and MSFT, covariance measures how two variables move together (not normalized)
print("Covariance AAPL & MSFT:", returns["AAPL"].cov(returns["MSFT"]))
print('-' * 40)
print("Correlation Matrix:\n", returns.corr()) # Generate correlation matrix for all stocks
print('-' * 40)
print("Covariance Matrix:\n", returns.cov()) # Generate covariance matrix for all stocks
print('-' * 40)
print("Correlation with AAPL:\n", returns.corrwith(returns["AAPL"])) # Calculate correlation of each stock with AAPL
print('-' * 40)

"""# Unique Values, Value Counts, and Membership"""

obj = pd.Series(["c", "a", "d", "a", "a", "b", "b", "c", "c"])
uniques = obj.unique() # get unique values from the series
print(uniques)
print('-' * 30)
print(obj.value_counts())
print('-' * 30)
# Convert the Series to a NumPy array, then count the frequency of each unique value without sorting
print(pd.value_counts(obj.to_numpy(), sort=False))
print('-' * 30)
print(obj)
print('-' * 30)
mask = obj.isin(['b', 'c']) # Create a Boolean mask where True indicates values in the Series that are either 'b' or 'c'
print(mask)
print('-' * 30)
print(obj[mask]) # Filter the Series using the Boolean mask, keeping only elements that are 'b' or 'c'
print('-' * 30)
to_match = pd.Series(["c", "a", "b", "b", "c", "a"])
unique_vals = pd.Series(["c", "b", "a"])
indices = pd.Index(unique_vals).get_indexer(to_match) # Create an index from unique_vals, then map each value in to_match to its position
print(indices)
print('-' * 30)

# Create a DataFrame with 3 questions and their answers
data = pd.DataFrame({"Qu1": [1, 3, 4, 3, 4],"Qu2": [2, 3, 1, 2, 3],"Qu3": [1, 5, 2, 4, 4]})
print(data)
print('-' * 30)
print(data["Qu1"].value_counts().sort_index()) # Count frequency of each unique value in Qu1, then sort by index
print('-' * 30)
results = data.apply(pd.value_counts).fillna(0) # Count frequency of unique values per column and replace NaN with 0
print(results)
print('-' * 30)
data = pd.DataFrame({"a": [1, 1, 1, 2, 2], "b": [0, 0, 1, 0, 0]})
print(data)
print('-' * 30)
print(data.value_counts()) # Count how many times each unique row appears in the DataFrame
print('-' * 30)